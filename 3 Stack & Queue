/*
  3.1
  Three in one: Describe how you could use a single array to implement three stacks
*/
// 1
// Use one array and use indexes to place stack elements. (currentInd1,2,3 etc)
// First stack item will be 0, second at 1, third at 3 and then repeat every 3 elements

//-----------------------------------------------------------------------------------------

/*
  3.2
  Stack Min: 
  How would you design a stack which, in addition to push and pop, has a function min that 
  returns the minimum element? Push, pop and min should operate in O(1) time
*/
// 1
// Store min in a variable inside and check for a new min on a push
// (can't know min after pop()) 

// 2
// Store array of mins inside, push there elements that are min on each state

//-----------------------------------------------------------------------------------------

/*
  3.3
  Stack of plates: Imagine a stack of plates. If the stack gets too high, it might topple.
  Therefore, in real life, we would likely start a new stack when the previous stack exceeds some
  threshold. Implement a data structure setOfStacks that mimics this. setOfStacks must be composed
  of several stacks and could create a new stack once the previous one exceeds the capacity.
  setOfStacks.push() and setOfStacks.pop() should behave identically to a single stack
*/

// Use one array and control current amount of elements and locations with index pointers
// Or use previous approach (with pointers on 1,2,3 jump to each 3rd element representing stack)

//-----------------------------------------------------------------------------------------
/*
  Queue via Stacks: Implement a queue using stacks
*/

// 1
// Use two stacks and on each pop():
//  - Put all elements into a second stack and return one on top
//  - Then return all the elements into a first stack back

// 2
// ?

//-----------------------------------------------------------------------------------------
/*
  Sort Stacks: Write a program to sort a stack such that the smallest item is on the top.You can use
  an additional temporary stack but you may not copy the elements into any other data structure.
  The stack supports the following operations : push, pop, peek and isEmpty
*/

// 1
// Taking one item from a stack - 'a'
// Then do a variation of insertion sort:
// Pop out elements to find a right place for 'a'
// Keep elements in another stack meanwhile 

//-----------------------------------------------------------------------------------------
/*
  Route between nodes: Given a directed graph, design an algorithm to find out whether there is a route
  between two nodes.
*/



//-----------------------------------------------------------------------------------------
/*
Minimal Tree: Given a sorted array with unique integer elements, write an algorithm to create a 
binary search tree with minimal height.
*/


//-----------------------------------------------------------------------------------------

/*
List of depths: Given a binary tree, design an algorithm which creates a linked list
of all the nodes at each depth (i.e. if you have a tree with depth D, you will have D linked lists)
*/

//-----------------------------------------------------------------------------------------
/*
Check Balanced: Implement a function to check if a binary function is
balanced or not. 
A balanced tree is defined to be a tree such that the difference in the heights
between the two subtrees of a node is never greater than one
*/


//-----------------------------------------------------------------------------------------
/*
Valid BST:  Implement a function to check if a binary tree is a binary search tree
BST: left <= current < right
*/


//-----------------------------------------------------------------------------------------

/*
Successor : Write an algorithm to find the next node(i.e. inorder successor) of a given node 
in a binary search tree. You may assume that each node has a link to its parent node
Approach : If a right node exists, return the left most node in the right sub tree
else, go to the parent until the child is a left child of the parent
*/

//-----------------------------------------------------------------------------------------
/*
Build Order: You are given a list of projects and a list of dependencies (which is a list of pair of projects, where
the second project is dependent on the first). All of a project's dependencies must be built before the project is.
Find a build order that will allow the projects to be built. If there is no valid order, return an error.
*/


//-----------------------------------------------------------------------------------------

/*
First common ancestor : Design an algorithm and write a code to find the first common ancestor of two
nodes in a binary tree. Avoid storing additional nodes in a data structure.
Note : This is not necessarily a binary search tree
*/

//-----------------------------------------------------------------------------------------

/*
BST Sequences: A binary search tree was created by tranversing an array from left to right
and inserting each element.Given a binary search tree with distinct elements, print all possible
arrays that could have led to this tree.
*/



